{
  "folderName": "bindings",
  "folderPath": ".autodoc/docs/json/weave-js/src/core/language/js/parser/js-grammar/bindings",
  "url": "https://github.com/wandb/weave/.autodoc/docs/json/weave-js/src/core/language/js/parser/js-grammar/bindings",
  "files": [],
  "folders": [
    {
      "folderName": "node",
      "folderPath": ".autodoc/docs/json/weave-js/src/core/language/js/parser/js-grammar/bindings/node",
      "url": "https://github.com/wandb/weave/.autodoc/docs/json/weave-js/src/core/language/js/parser/js-grammar/bindings/node",
      "files": [
        {
          "fileName": "binding.cc",
          "filePath": "weave-js/src/core/language/js/parser/js-grammar/bindings/node/binding.cc",
          "url": "https://github.com/wandb/weave/weave-js/src/core/language/js/parser/js-grammar/bindings/node/binding.cc",
          "summary": "This code is a C++ file that is part of the larger Weave project. The purpose of this code is to provide a language binding for the Tree-sitter parsing library. Tree-sitter is a parsing library that can be used to parse source code into an abstract syntax tree (AST). This AST can then be used for various purposes, such as syntax highlighting, code completion, and refactoring.\n\nThe code defines a function called `tree_sitter_weave()` that returns a pointer to a `TSLanguage` struct. This struct contains information about the syntax of the Weave programming language, such as the names of the different types of nodes in the AST and the rules for parsing the source code. This function is declared as `extern \"C\"` to ensure that it has a C-style function signature, which is required by the Tree-sitter library.\n\nThe code also defines a function called `Init()` that is used to initialize the language binding. This function creates a new `FunctionTemplate` object that is used to define a constructor function for the language binding. The constructor function is then used to create a new instance of the `Language` class, which is a wrapper around the `TSLanguage` struct. The `Language` class provides a more convenient interface for working with the `TSLanguage` struct.\n\nThe `Init()` function then sets the name of the language to \"weave\" and exports the `Language` instance as the module's main export. This allows other parts of the Weave project to use the language binding to parse Weave source code into an AST.\n\nHere is an example of how this code might be used in the larger Weave project:\n\n```javascript\nconst Parser = require(\"tree-sitter\");\nconst Weave = require(\"./weave\");\n\nconst parser = new Parser();\nparser.setLanguage(Weave);\n\nconst sourceCode = `\n  function add(a, b) {\n    return a + b;\n  }\n`;\n\nconst tree = parser.parse(sourceCode);\n\nconsole.log(tree.rootNode.toString());\n```\n\nIn this example, the code creates a new `Parser` object and sets its language to the Weave language binding. It then parses a simple Weave function and prints the resulting AST to the console.",
          "questions": "1. What is the purpose of this code?\n   - This code is a C++ module that exports a Tree-sitter language parser for the \"weave\" language.\n\n2. What dependencies does this code have?\n   - This code depends on the Tree-sitter parser library and the Node.js C++ addon library.\n\n3. How is the \"weave\" language parser being exported?\n   - The \"weave\" language parser is being exported as a Node.js module using the NODE_MODULE macro and the Nan library. The exported module is an instance of a C++ class that wraps the Tree-sitter parser."
        },
        {
          "fileName": "index.js",
          "filePath": "weave-js/src/core/language/js/parser/js-grammar/bindings/node/index.js",
          "url": "https://github.com/wandb/weave/weave-js/src/core/language/js/parser/js-grammar/bindings/node/index.js",
          "summary": "This code is responsible for exporting a Node.js module called `tree_sitter_weave_binding` and a JSON file called `node-types.json`. The `tree_sitter_weave_binding` module is a native addon that provides a C++ binding for the Tree-sitter parsing library. \n\nThe code first tries to export the `tree_sitter_weave_binding` module from the `build/Release` directory. If this fails with a `MODULE_NOT_FOUND` error, it tries to export the module from the `build/Debug` directory. If this also fails with a `MODULE_NOT_FOUND` error, it throws the original error from the `build/Release` attempt.\n\nThe `nodeTypeInfo` property is then added to the exported module, which requires the `node-types.json` file from the `src` directory. This JSON file contains information about the syntax tree nodes that are produced by the parser. \n\nThis code is important for the larger `weave` project because it provides a way to parse and analyze source code written in the `weave` language. The `tree_sitter_weave_binding` module allows the project to use the efficient and flexible Tree-sitter parsing library, while the `node-types.json` file provides a standardized way to identify and work with the different types of syntax tree nodes that are produced by the parser.\n\nHere is an example of how this code might be used in the `weave` project:\n\n```javascript\nconst parser = require('weave').parser;\nconst sourceCode = '...'; // some `weave` source code\nconst tree = parser.parse(sourceCode);\n\n// Traverse the syntax tree and do something with each node\ntree.walk((node) => {\n  if (node.type === 'function_declaration') {\n    console.log(`Found function: ${node.name}`);\n  }\n});\n```\n\nIn this example, the `weave` module is imported and the `parser` object is accessed. The `parse` method is then called with some `weave` source code, which returns a syntax tree. The `walk` method is used to traverse the tree and log the name of each function declaration node. This is made possible by the `node-types.json` file, which defines the `function_declaration` node type.",
          "questions": "1. What is the purpose of this code?\n   This code is attempting to export a C++ addon module called `tree_sitter_weave_binding` and its associated `node-types.json` file, with fallbacks to different build configurations if necessary.\n\n2. What is the expected directory structure for this code to work?\n   This code assumes that the `tree_sitter_weave_binding` module and `node-types.json` file are located in the `build/Release` or `build/Debug` directories relative to the current file.\n\n3. What happens if the `tree_sitter_weave_binding` module or `node-types.json` file cannot be found?\n   If the `tree_sitter_weave_binding` module cannot be found in either the `Release` or `Debug` directories, or if the `node-types.json` file cannot be found in the `src` directory, an error will be thrown."
        }
      ],
      "folders": [],
      "summary": "The `binding.cc` file in the `weave-js/src/core/language/js/parser/js-grammar/bindings/node` folder is responsible for providing a language binding for the Tree-sitter parsing library. Tree-sitter is a parsing library that can parse source code into an abstract syntax tree (AST), which can be used for various purposes such as syntax highlighting, code completion, and refactoring.\n\nThe code defines a function called `tree_sitter_weave()` that returns a pointer to a `TSLanguage` struct, containing information about the syntax of the Weave programming language. The `Init()` function initializes the language binding by creating a new `FunctionTemplate` object, defining a constructor function for the language binding, and creating a new instance of the `Language` class, which is a wrapper around the `TSLanguage` struct.\n\nHere's an example of how this code might be used in the larger Weave project:\n\n```javascript\nconst Parser = require(\"tree-sitter\");\nconst Weave = require(\"./weave\");\n\nconst parser = new Parser();\nparser.setLanguage(Weave);\n\nconst sourceCode = `\n  function add(a, b) {\n    return a + b;\n  }\n`;\n\nconst tree = parser.parse(sourceCode);\n\nconsole.log(tree.rootNode.toString());\n```\n\nThe `index.js` file exports a Node.js module called `tree_sitter_weave_binding` and a JSON file called `node-types.json`. The `tree_sitter_weave_binding` module is a native addon that provides a C++ binding for the Tree-sitter parsing library. The `node-types.json` file contains information about the syntax tree nodes produced by the parser.\n\nThis code is important for the larger `weave` project because it provides a way to parse and analyze source code written in the `weave` language. The `tree_sitter_weave_binding` module allows the project to use the efficient and flexible Tree-sitter parsing library, while the `node-types.json` file provides a standardized way to identify and work with the different types of syntax tree nodes produced by the parser.\n\nHere's an example of how this code might be used in the `weave` project:\n\n```javascript\nconst parser = require('weave').parser;\nconst sourceCode = '...'; // some `weave` source code\nconst tree = parser.parse(sourceCode);\n\n// Traverse the syntax tree and do something with each node\ntree.walk((node) => {\n  if (node.type === 'function_declaration') {\n    console.log(`Found function: ${node.name}`);\n  }\n});\n```\n\nIn this example, the `weave` module is imported and the `parser` object is accessed. The `parse` method is then called with some `weave` source code, which returns a syntax tree. The `walk` method is used to traverse the tree and log the name of each function declaration node. This is made possible by the `node-types.json` file, which defines the `function_declaration` node type.",
      "questions": ""
    },
    {
      "folderName": "rust",
      "folderPath": ".autodoc/docs/json/weave-js/src/core/language/js/parser/js-grammar/bindings/rust",
      "url": "https://github.com/wandb/weave/.autodoc/docs/json/weave-js/src/core/language/js/parser/js-grammar/bindings/rust",
      "files": [
        {
          "fileName": "lib.rs",
          "filePath": "weave-js/src/core/language/js/parser/js-grammar/bindings/rust/lib.rs",
          "url": "https://github.com/wandb/weave/weave-js/src/core/language/js/parser/js-grammar/bindings/rust/lib.rs",
          "summary": "This code provides support for the weave language in the tree-sitter parsing library. The `language()` function is used to add the weave language to a tree-sitter parser, which can then be used to parse code written in the weave language. The `language()` function returns the tree-sitter `Language` for the weave grammar. \n\nTo use this code, you would first create a new parser using `tree_sitter::Parser::new()`. Then, you would call `parser.set_language(tree_sitter_weave::language())` to add the weave language to the parser. Finally, you would call `parser.parse(code, None)` to parse some code written in the weave language. \n\nThe `NODE_TYPES` constant provides the content of the `node-types.json` file for this grammar. This file defines the types of nodes that can be present in the parse tree for the weave language. \n\nThe code also includes commented-out constants for any queries that this grammar contains. These queries can be used to extract specific information from the parse tree, such as highlighting information or tag information. \n\nThe `tests` module includes a single test that verifies that the weave language can be loaded by a tree-sitter parser. \n\nOverall, this code provides the necessary support for parsing code written in the weave language using the tree-sitter parsing library.",
          "questions": "1. What is the purpose of this code?\n   \n   This code provides weave language support for the tree-sitter parsing library. It defines a language function that adds the language to a tree-sitter parser and provides the content of the node-types.json file for this grammar.\n\n2. How do you use this code to parse some code?\n   \n   You can use the tree-sitter parser to parse some code by setting the language to tree_sitter_weave::language() and then calling the parser.parse() function with the code to parse.\n\n3. What are the other queries that this grammar contains?\n   \n   This code includes commented out constants for other queries that this grammar contains, including HIGHLIGHTS_QUERY, INJECTIONS_QUERY, LOCALS_QUERY, and TAGS_QUERY."
        }
      ],
      "folders": [],
      "summary": "The `lib.rs` file in the `rust` folder provides support for the Weave language in the Tree-sitter parsing library. Tree-sitter is a parsing library that generates syntax trees for source code, making it easier to analyze and manipulate the structure of the code. The Weave language is a custom language that needs to be added to the Tree-sitter parser to enable parsing of Weave code.\n\nThe primary function in this file is `language()`, which returns the Tree-sitter `Language` for the Weave grammar. To use this function, you would first create a new parser using `tree_sitter::Parser::new()`. Then, you would call `parser.set_language(tree_sitter_weave::language())` to add the Weave language to the parser. Finally, you would call `parser.parse(code, None)` to parse some code written in the Weave language. Here's an example of how this code might be used:\n\n```rust\nuse tree_sitter::Parser;\nuse tree_sitter_weave;\n\nfn main() {\n    let mut parser = Parser::new();\n    parser.set_language(tree_sitter_weave::language()).unwrap();\n    let code = \"some Weave code\";\n    let tree = parser.parse(code, None).unwrap();\n    println!(\"{:?}\", tree.root_node());\n}\n```\n\nThe `NODE_TYPES` constant provides the content of the `node-types.json` file for this grammar. This file defines the types of nodes that can be present in the parse tree for the Weave language. This information is useful for developers who want to analyze or manipulate the parse tree generated by the Tree-sitter parser.\n\nThe code also includes commented-out constants for any queries that this grammar contains. These queries can be used to extract specific information from the parse tree, such as highlighting information or tag information. Developers can uncomment these constants and use them to perform advanced operations on the parse tree.\n\nThe `tests` module includes a single test that verifies that the Weave language can be loaded by a Tree-sitter parser. This test ensures that the Weave language support is functioning correctly and can be used in other parts of the project.\n\nIn summary, the `lib.rs` file in the `rust` folder provides the necessary support for parsing code written in the Weave language using the Tree-sitter parsing library. This support enables developers to analyze and manipulate Weave code in a structured manner, making it easier to work with the Weave language in the larger project.",
      "questions": ""
    }
  ],
  "summary": "The `bindings` folder in the `weave-js/src/core/language/js/parser/js-grammar` directory contains language bindings for the Weave programming language, enabling the Tree-sitter parsing library to parse and analyze Weave source code. Tree-sitter is a parsing library that generates abstract syntax trees (ASTs) for source code, which can be used for various purposes such as syntax highlighting, code completion, and refactoring.\n\nThe `bindings` folder has two subfolders: `node` and `rust`. Each subfolder provides language bindings for different programming languages.\n\n### Node\n\nThe `node` subfolder contains the `binding.cc` file, which defines a function called `tree_sitter_weave()` that returns a pointer to a `TSLanguage` struct, containing information about the syntax of the Weave programming language. The `Init()` function initializes the language binding by creating a new `FunctionTemplate` object, defining a constructor function for the language binding, and creating a new instance of the `Language` class, which is a wrapper around the `TSLanguage` struct.\n\nExample usage:\n\n```javascript\nconst Parser = require(\"tree-sitter\");\nconst Weave = require(\"./weave\");\n\nconst parser = new Parser();\nparser.setLanguage(Weave);\n\nconst sourceCode = `\n  function add(a, b) {\n    return a + b;\n  }\n`;\n\nconst tree = parser.parse(sourceCode);\n\nconsole.log(tree.rootNode.toString());\n```\n\nThe `index.js` file exports a Node.js module called `tree_sitter_weave_binding` and a JSON file called `node-types.json`. The `tree_sitter_weave_binding` module is a native addon that provides a C++ binding for the Tree-sitter parsing library. The `node-types.json` file contains information about the syntax tree nodes produced by the parser.\n\nExample usage:\n\n```javascript\nconst parser = require('weave').parser;\nconst sourceCode = '...'; // some `weave` source code\nconst tree = parser.parse(sourceCode);\n\n// Traverse the syntax tree and do something with each node\ntree.walk((node) => {\n  if (node.type === 'function_declaration') {\n    console.log(`Found function: ${node.name}`);\n  }\n});\n```\n\n### Rust\n\nThe `rust` subfolder contains the `lib.rs` file, which provides support for the Weave language in the Tree-sitter parsing library. The primary function in this file is `language()`, which returns the Tree-sitter `Language` for the Weave grammar.\n\nExample usage:\n\n```rust\nuse tree_sitter::Parser;\nuse tree_sitter_weave;\n\nfn main() {\n    let mut parser = Parser::new();\n    parser.set_language(tree_sitter_weave::language()).unwrap();\n    let code = \"some Weave code\";\n    let tree = parser.parse(code, None).unwrap();\n    println!(\"{:?}\", tree.root_node());\n}\n```\n\nThe `NODE_TYPES` constant provides the content of the `node-types.json` file for this grammar. The `tests` module includes a single test that verifies that the Weave language can be loaded by a Tree-sitter parser.\n\nIn summary, the `bindings` folder provides the necessary support for parsing code written in the Weave language using the Tree-sitter parsing library. This support enables developers to analyze and manipulate Weave code in a structured manner, making it easier to work with the Weave language in the larger project.",
  "questions": ""
}