{
  "folderName": "engine",
  "folderPath": ".autodoc/docs/json/weave-js/src/core/engine",
  "url": "https://github.com/wandb/weave/.autodoc/docs/json/weave-js/src/core/engine",
  "files": [
    {
      "fileName": "types.ts",
      "filePath": "weave-js/src/core/engine/types.ts",
      "url": "https://github.com/wandb/weave/weave-js/src/core/engine/types.ts",
      "summary": "The code defines an interface called `Engine` that is used in the larger `weave` project. The `Engine` interface has two methods: `executeNodes` and `mapNode`. \n\nThe `executeNodes` method takes an array of executable nodes and asynchronously resolves them for a result. The `targetNodes` parameter is an array of `NodeOrVoidNode` types, which are nodes that can either be a regular node or a void node. The `stripTags` parameter is an optional boolean that determines whether or not to strip tags from the result. The `resetBackendExecutionCache` parameter is also an optional boolean that determines whether or not to reset the backend execution cache. The method returns a promise that resolves to an array of any type.\n\nHere is an example of how to use the `executeNodes` method:\n\n```\nconst nodes = [node1, node2, node3];\nconst engine = new EngineImpl(opStore);\nengine.executeNodes(nodes, true, false)\n  .then(result => console.log(result))\n  .catch(error => console.error(error));\n```\n\nThe `mapNode` method takes a function node and an array of inputs, calls the function node over each element in the input, and returns an array of results. The `node` parameter is a `NodeOrVoidNode` type, which is a node that can either be a regular node or a void node. The `inputs` parameter is an array of any type that represents the inputs to the function node. The `stripTags` parameter is an optional boolean that determines whether or not to strip tags from the result. The method returns a promise that resolves to an array of any type.\n\nHere is an example of how to use the `mapNode` method:\n\n```\nconst node = functionNode;\nconst inputs = [input1, input2, input3];\nconst engine = new EngineImpl(opStore);\nengine.mapNode(node, inputs, true)\n  .then(result => console.log(result))\n  .catch(error => console.error(error));\n```",
      "questions": "1. What is the purpose of the `Engine` interface?\n   - The `Engine` interface defines the methods and properties that an engine object should have, including an `opStore` property and two methods for executing nodes and mapping nodes.\n2. What is the `executeNodes` method used for?\n   - The `executeNodes` method takes an array of executable nodes and resolves them asynchronously for a result. It also has optional parameters for stripping tags and resetting the backend execution cache.\n3. What is the `mapNode` method used for?\n   - The `mapNode` method takes a function node and an array of inputs, calls the function node over each element in the input, and returns an array of results. It also has an optional parameter for stripping tags."
    }
  ],
  "folders": [
    {
      "folderName": "forwardGraph",
      "folderPath": ".autodoc/docs/json/weave-js/src/core/engine/forwardGraph",
      "url": "https://github.com/wandb/weave/.autodoc/docs/json/weave-js/src/core/engine/forwardGraph",
      "files": [
        {
          "fileName": "base.ts",
          "filePath": "weave-js/src/core/engine/forwardGraph/base.ts",
          "url": "https://github.com/wandb/weave/weave-js/src/core/engine/forwardGraph/base.ts",
          "summary": "The `BaseForwardGraph` class in this code is responsible for managing a directed acyclic graph (DAG) of operations (Ops) and their relationships. The graph represents a computation pipeline, where each Op performs a specific task and passes its output to the next Op(s) in the pipeline. The code focuses on managing the relationships between Ops, specifically handling \"tag\" consumers and creators.\n\nTags are used to associate specific Ops with their corresponding input or output data. The code provides several utility functions to determine if an Op is a tag consumer or creator, and to extract and connect tag consumers with their respective tag creators.\n\nThe `updateForwardGraphVisitOp` function is the core function for updating the graph when a new node is added or an existing node is updated. It handles the traversal of the graph, updating the relationships between Ops, and connecting tag providers and consumers.\n\nThe `connectTagProviderToConsumers` function is responsible for associating tag consumers with their corresponding tag creators. It ensures that the correct input data is passed between Ops in the pipeline.\n\nThe `BaseForwardGraph` class can be used in a larger project to manage a computation pipeline, allowing for efficient updates and traversal of the graph as new operations are added or existing operations are modified.\n\nExample usage:\n\n```javascript\nconst graph = new BaseForwardGraph(storage);\ngraph.update(node);\nconst roots = graph.getRoots();\n```\n\nIn this example, a new `BaseForwardGraph` instance is created with a given storage, a node is updated, and the root nodes of the graph are retrieved.",
          "questions": "1. **Question**: What is the purpose of the `isTagConsumer` and `isTagCreator` functions, and how do they determine if an operation is a tag consumer or creator?\n   **Answer**: The `isTagConsumer` function checks if a given `forwardOp` is a tag consumer operation by checking its name against a hardcoded list of supported operations. Similarly, the `isTagCreator` function checks if a given `sourceOp` is a tag creator for a specific `targetOpName` by checking its name against a hardcoded list of supported operations and following certain naming conventions. These functions help in determining the relationship between operations in terms of tag consumption and creation.\n\n2. **Question**: What is the role of the `getLambdaFunctionNodes` function, and why are there several hardcoded operations within it?\n   **Answer**: The `getLambdaFunctionNodes` function is responsible for retrieving the lambda function nodes associated with a given `forwardOp`. It has hardcoded operations because it currently supports only a specific set of operations and needs to re-implement the way these operations apply lambda functions to their inputs, which is hidden at the moment. The TODO comments indicate that this should be made more generic in the future.\n\n3. **Question**: What is the purpose of the `BaseForwardGraph` class, and how does it interact with the `ForwardGraphStorage`?\n   **Answer**: The `BaseForwardGraph` class implements the `ForwardGraph` interface and serves as the base class for managing and updating the forward graph representation of the operations. It interacts with the `ForwardGraphStorage` by using it to store and retrieve `ForwardOp` instances, as well as to manage the root operations in the graph. The class provides methods for updating the graph, connecting tag providers and consumers, and traversing the graph."
        },
        {
          "fileName": "hashing.ts",
          "filePath": "weave-js/src/core/engine/forwardGraph/hashing.ts",
          "url": "https://github.com/wandb/weave/weave-js/src/core/engine/forwardGraph/hashing.ts",
          "summary": "The `HashingStorage` class is a part of the `weave` project and is responsible for storing and managing the forward operations of a graph. The class implements the `ForwardGraphStorage` interface, which defines the methods for managing the forward operations of a graph.\n\nThe class has three private properties: `hash`, `roots`, and `ops`. The `hash` property is an instance of the `Hasher` class, which is used to generate unique identifiers for the operations. The `roots` property is a `Set` that stores the root operations of the graph. The `ops` property is a `Map` that stores the forward operations of the graph.\n\nThe constructor of the class initializes the `hash` property with an instance of the `MemoizedHasher` class. The `MemoizedHasher` class is a subclass of the `Hasher` class that caches the hash values of the operations to improve performance.\n\nThe `getRoots` method returns the `roots` property, which is a `Set` of the root operations of the graph.\n\nThe `getOp` method takes an operation as an argument and returns the corresponding forward operation from the `ops` property. The `opId` method of the `hash` property is used to generate a unique identifier for the operation, which is used as the key to retrieve the forward operation from the `ops` property.\n\nThe `setOp` method takes a forward operation as an argument and adds it to the `ops` property. The `opId` method of the `hash` property is used to generate a unique identifier for the operation, which is used as the key to store the forward operation in the `ops` property.\n\nThe `size` method returns the number of forward operations stored in the `ops` property.\n\nOverall, the `HashingStorage` class provides a way to store and manage the forward operations of a graph in the `weave` project. It uses a `Hasher` instance to generate unique identifiers for the operations and stores them in a `Map`. The class can be used to retrieve and add forward operations to the graph.",
          "questions": "1. What is the purpose of the `HashingStorage` class?\n- The `HashingStorage` class is a implementation of the `ForwardGraphStorage` interface that provides methods for getting and setting operations in a graph, as well as keeping track of the roots of the graph.\n\n2. What is the significance of the `MemoizedHasher` class?\n- The `MemoizedHasher` class is used to generate unique IDs for operations in the graph, which are used as keys in the `ops` map.\n\n3. What is the relationship between the `HashingStorage` class and the `Hasher` and `ForwardOp` classes?\n- The `HashingStorage` class uses an instance of the `Hasher` class to generate IDs for operations, and stores instances of the `ForwardOp` class in its `ops` map."
        },
        {
          "fileName": "index.ts",
          "filePath": "weave-js/src/core/engine/forwardGraph/index.ts",
          "url": "https://github.com/wandb/weave/weave-js/src/core/engine/forwardGraph/index.ts",
          "summary": "The code above is a module that exports two functions, `newForwardGraph()` and `newRefForwardGraph()`, as well as some types and utilities. These functions create instances of a `BaseForwardGraph` class, which is defined in another file called `base.ts`. The `BaseForwardGraph` class takes a storage object as an argument, which can be either a `HashingStorage` or a `RefStorage` object, depending on which function is called.\n\nThe purpose of this module is to provide a way to create instances of a forward graph, which is a data structure used in the larger project. A forward graph is a directed acyclic graph (DAG) that represents a computation graph, where nodes represent operations and edges represent data dependencies between those operations. The forward graph is used to track the flow of data through the computation graph and to perform automatic differentiation.\n\nThe `newForwardGraph()` function creates a forward graph with a `HashingStorage` object, which is a storage implementation that uses a hash table to store nodes and edges. This implementation is efficient for small to medium-sized graphs. The `newRefForwardGraph()` function creates a forward graph with a `RefStorage` object, which is a storage implementation that uses a reference counting scheme to manage memory. This implementation is more memory-efficient for large graphs.\n\nHere is an example of how to use these functions:\n\n```typescript\nimport { newForwardGraph } from 'weave';\n\nconst graph = newForwardGraph();\n\n// Add nodes and edges to the graph\nconst a = graph.addOp('input', []);\nconst b = graph.addOp('input', []);\nconst c = graph.addOp('add', [a, b]);\nconst d = graph.addOp('mul', [c, b]);\n\n// Evaluate the graph\nconst inputs = { [a]: 2, [b]: 3 };\nconst outputs = graph.evaluate([d], inputs);\n\nconsole.log(outputs); // { [d]: 15 }\n```\n\nIn this example, we create a new forward graph using `newForwardGraph()`. We then add four nodes to the graph: two input nodes (`a` and `b`), an addition node (`c`) that depends on `a` and `b`, and a multiplication node (`d`) that depends on `c` and `b`. We then evaluate the graph by passing in the output node (`d`) and an object that maps input nodes to their values. The `evaluate()` method returns an object that maps output nodes to their values. In this case, the output value of `d` is `15`, which is the result of `(2 + 3) * 3`.",
          "questions": "1. What is the purpose of the `BaseForwardGraph` class and how is it used in this code?\n   - The `BaseForwardGraph` class is imported from the `base` module and is used to create instances of a forward graph. It is used in the `newForwardGraph` and `newRefForwardGraph` functions to create new instances of a forward graph with different types of storage.\n2. What is the difference between `HashingStorage` and `RefStorage` and how do they affect the behavior of the forward graph?\n   - `HashingStorage` and `RefStorage` are two different implementations of the storage mechanism for the forward graph. `HashingStorage` uses a hash table to store the values, while `RefStorage` uses a reference-based approach. The choice of storage mechanism can affect the performance and memory usage of the forward graph.\n3. What is the purpose of the `ForwardOp` type and how is it used in this code?\n   - The `ForwardOp` type is exported from the `types` module and is used to define the signature of a function that can be added to the forward graph as an operation. It is also re-exported from this module along with the `ForwardGraph` type."
        },
        {
          "fileName": "ref.ts",
          "filePath": "weave-js/src/core/engine/forwardGraph/ref.ts",
          "url": "https://github.com/wandb/weave/weave-js/src/core/engine/forwardGraph/ref.ts",
          "summary": "The code above defines a class called `RefStorage` that implements the `ForwardGraphStorage` interface. This class is part of the larger `weave` project and is responsible for storing and managing references to forward operations in a graph.\n\nThe `RefStorage` class has two private properties: `roots` and `ops`. The `roots` property is a `Set` that stores references to all the root operations in the graph. The `ops` property is a `Map` that stores references to all the forward operations in the graph. \n\nThe `RefStorage` class has four methods: `getRoots()`, `getOp()`, `setOp()`, and `size()`. \n\nThe `getRoots()` method returns the `roots` set, which contains references to all the root operations in the graph. \n\nThe `getOp()` method takes an operation (`GraphTypes.Op`) as an argument and returns the corresponding forward operation (`ForwardOp`) from the `ops` map. If the operation is not found in the map, `undefined` is returned.\n\nThe `setOp()` method takes a forward operation (`ForwardOp`) as an argument and adds it to the `ops` map. The key for the map is the `op` property of the forward operation.\n\nThe `size()` method returns the number of forward operations stored in the `ops` map.\n\nThis class is likely used in conjunction with other classes in the `weave` project to build and manipulate a graph of operations. For example, the `setOp()` method may be called when a new forward operation is added to the graph, and the `getRoots()` method may be used to retrieve all the root operations in the graph. \n\nHere is an example of how the `RefStorage` class may be used:\n\n```\nconst storage = new RefStorage();\nconst op1 = new ForwardOp();\nconst op2 = new ForwardOp();\nstorage.setOp(op1);\nstorage.setOp(op2);\nconsole.log(storage.size()); // Output: 2\n```",
          "questions": "1. What is the purpose of the `RefStorage` class?\n- The `RefStorage` class is a implementation of the `ForwardGraphStorage` interface and provides methods for managing a set of `ForwardOp` objects and their relationships.\n\n2. What is the significance of the `roots` and `ops` properties?\n- The `roots` property is a set of `ForwardOp` objects that are considered the starting points of the graph. The `ops` property is a map that associates `GraphTypes.Op` objects with their corresponding `ForwardOp` objects.\n\n3. What is the expected behavior of the `setOp` method?\n- The `setOp` method adds a `ForwardOp` object to the `ops` map, using its `op` property as the key."
        },
        {
          "fileName": "types.ts",
          "filePath": "weave-js/src/core/engine/forwardGraph/types.ts",
          "url": "https://github.com/wandb/weave/weave-js/src/core/engine/forwardGraph/types.ts",
          "summary": "This file contains TypeScript interfaces for a forward graph used in the larger project called \"weave\". The forward graph is a data structure used to represent a computation graph where each node represents an operation and edges represent data flow between operations. \n\nThe `ForwardOp` interface represents an operation in the forward graph and contains two properties: `op` which is the operation being performed and `outputNode` which is the node in the graph that represents the output of the operation. \n\nThe `ForwardNode` interface represents a node in the forward graph and contains several properties. `node` is the output node that this forward node represents. `inputTo` is a set of forward operations that consume the output of this node. `descendantTagConsumersWithAncestorProvider` is a dictionary where the keys are operation names and the values are sets of forward operations that consume the output of this node and have a common ancestor operation. `consumedAsTagBy` is a set of forward operations that consume the output of this node as a tag. `consumesTagFrom` is a set of forward operations that consume a tag from this node. `lambdaFnNodes` is an optional array of output nodes that represent lambda functions. Finally, `result` is a legacy field that should not be used.\n\nThe `ForwardGraphStorage` interface defines methods for accessing and modifying the forward graph. `getRoots()` returns a set of all the root forward operations in the graph. `getOp(op)` returns the forward operation that corresponds to the given operation `op`. `setOp(op)` adds the given forward operation to the graph. `size()` returns the number of forward operations in the graph.\n\nThe `ForwardGraph` interface extends `ForwardGraphStorage` and adds two methods. `update(node)` updates the forward graph with the given node. `size()` returns the number of forward operations in the graph.\n\nOverall, this file provides the necessary interfaces for representing and manipulating a forward graph in the larger \"weave\" project. Here is an example of how these interfaces might be used:\n\n```\nimport { ForwardGraph, ForwardOp } from 'weave';\n\nconst graph: ForwardGraph = createForwardGraph();\n\nconst op1: ForwardOp = {\n  op: 'add',\n  outputNode: createOutputNode(),\n};\n\nconst op2: ForwardOp = {\n  op: 'multiply',\n  outputNode: createOutputNode(),\n};\n\ngraph.setOp(op1);\ngraph.setOp(op2);\n\ngraph.update(createNode(op1, op2));\n\nconsole.log(graph.size()); // 2\n```",
          "questions": "1. What is the purpose of the `ForwardOp` interface and its `op` and `outputNode` properties?\n   - The `ForwardOp` interface represents an operation in a forward graph and its `op` property is the corresponding operation in the underlying graph, while `outputNode` is the node in the forward graph that represents the output of the operation.\n2. What is the significance of the `descendantTagConsumersWithAncestorProvider` property in the `ForwardNode` interface?\n   - The `descendantTagConsumersWithAncestorProvider` property is a map of operation names to sets of `ForwardOp` objects, where each set contains operations that consume a tag produced by the `ForwardOp` object corresponding to the key operation name, and whose corresponding `ForwardNode` object has the key operation as an ancestor provider.\n3. What is the relationship between the `ForwardGraph` interface and the `ForwardGraphStorage` interface?\n   - The `ForwardGraph` interface extends the `ForwardGraphStorage` interface and adds an `update` method that updates the forward graph based on a given node in the underlying graph. Both interfaces also have a `size` method that returns the number of operations in the forward graph."
        },
        {
          "fileName": "util.ts",
          "filePath": "weave-js/src/core/engine/forwardGraph/util.ts",
          "url": "https://github.com/wandb/weave/weave-js/src/core/engine/forwardGraph/util.ts",
          "summary": "The `weave` project includes a file that contains a function called `forwardOpInputs`. This function takes in two parameters: a `ForwardGraph` object and a `ForwardOp` object. The purpose of this function is to return an object that maps input names to their corresponding values for a given `ForwardOp`. \n\nThe `ForwardGraph` object represents a directed acyclic graph (DAG) of operations, where each node represents an operation and each edge represents a data dependency between operations. The `ForwardOp` object represents a single operation in the graph. \n\nThe function uses the `mapValues` method from the `lodash` library to iterate over the `inputs` object of the given `ForwardOp`. For each input, the function checks the `nodeType` property to determine how to retrieve its value. \n\nIf the `nodeType` is `'output'`, the function retrieves the value of the output node's `result` property from the `ForwardOp` object that the input is connected to. This is done by using the `getOp` method of the `ForwardGraph` object to retrieve the `ForwardOp` object that the output node is connected to. \n\nIf the `nodeType` is `'const'`, the function retrieves the value of the `val` property from the input node. \n\nIf the `nodeType` is `'var'`, the function returns `undefined` since the value of the input is not yet known. \n\nThe function then returns an object that maps each input name to its corresponding value. \n\nThis function is likely used in the larger `weave` project to retrieve the input values for a given operation in the graph. This information can then be used to execute the operation and produce an output value. \n\nExample usage:\n\n```\nconst graph = new ForwardGraph();\n// add nodes and edges to graph\n\nconst op = graph.getOp('myOp');\nconst inputs = forwardOpInputs(graph, op);\n// inputs is an object that maps input names to their corresponding values\n// use inputs to execute the operation and produce an output value\n```",
          "questions": "1. What is the purpose of the `forwardOpInputs` function?\n   - The `forwardOpInputs` function takes in a `ForwardGraph` and a `ForwardOp` and returns an object containing the inputs for the given `ForwardOp`.\n2. What is the `mapValues` function from lodash being used for?\n   - The `mapValues` function is being used to iterate over the `inputs` object of the given `ForwardOp` and return a new object with the same keys but with the values transformed based on the logic in the function.\n3. What are the possible values for `inputNode.nodeType` and how are they handled in the function?\n   - The possible values for `inputNode.nodeType` are `'output'`, `'const'`, and `'var'`. They are handled differently in the function: if it is `'output'`, the function retrieves the output value from the corresponding `ForwardOp`; if it is `'const'`, the function returns the constant value; if it is `'var'`, the function returns `undefined`."
        }
      ],
      "folders": [],
      "summary": "The `forwardGraph` folder in the `weave-js` project contains the core implementation of a directed acyclic graph (DAG) that represents a computation pipeline. Each node in the graph represents an operation (Op), and edges represent data dependencies between these operations. The code in this folder is responsible for managing the relationships between Ops, specifically handling \"tag\" consumers and creators, which are used to associate specific Ops with their corresponding input or output data.\n\nThe `BaseForwardGraph` class, defined in `base.ts`, is the main class for managing the computation pipeline. It provides utility functions to determine if an Op is a tag consumer or creator, and to extract and connect tag consumers with their respective tag creators. The `updateForwardGraphVisitOp` function is the core function for updating the graph when a new node is added or an existing node is updated. It handles the traversal of the graph, updating the relationships between Ops, and connecting tag providers and consumers.\n\n```javascript\nconst graph = new BaseForwardGraph(storage);\ngraph.update(node);\nconst roots = graph.getRoots();\n```\n\nThe `HashingStorage` class in `hashing.ts` and the `RefStorage` class in `ref.ts` provide different storage implementations for the forward graph. `HashingStorage` uses a hash table to store nodes and edges, making it efficient for small to medium-sized graphs. `RefStorage` uses a reference counting scheme to manage memory, making it more memory-efficient for large graphs.\n\nThe `index.ts` file exports two functions, `newForwardGraph()` and `newRefForwardGraph()`, which create instances of a `BaseForwardGraph` class with either a `HashingStorage` or a `RefStorage` object, respectively.\n\n```typescript\nimport { newForwardGraph } from 'weave';\n\nconst graph = newForwardGraph();\n```\n\nThe `types.ts` file contains TypeScript interfaces for representing and manipulating a forward graph, such as `ForwardOp`, `ForwardNode`, and `ForwardGraphStorage`.\n\nThe `util.ts` file provides a utility function called `forwardOpInputs` that retrieves the input values for a given operation in the graph. This information can be used to execute the operation and produce an output value.\n\n```javascript\nconst graph = new ForwardGraph();\n// add nodes and edges to graph\n\nconst op = graph.getOp('myOp');\nconst inputs = forwardOpInputs(graph, op);\n```\n\nOverall, the code in the `forwardGraph` folder is essential for managing a computation pipeline in the larger `weave-js` project. It provides efficient updates and traversal of the graph as new operations are added or existing operations are modified.",
      "questions": ""
    }
  ],
  "summary": "The `types.ts` file in the `engine` folder of the `weave-js` project defines the `Engine` interface, which is crucial for executing and mapping nodes in the computation pipeline. The interface has two methods: `executeNodes` and `mapNode`.\n\nThe `executeNodes` method takes an array of executable nodes (`NodeOrVoidNode` types) and asynchronously resolves them for a result. It has two optional parameters: `stripTags`, which determines whether to strip tags from the result, and `resetBackendExecutionCache`, which determines whether to reset the backend execution cache. The method returns a promise that resolves to an array of any type. Here's an example of how to use the `executeNodes` method:\n\n```javascript\nconst nodes = [node1, node2, node3];\nconst engine = new EngineImpl(opStore);\nengine.executeNodes(nodes, true, false)\n  .then(result => console.log(result))\n  .catch(error => console.error(error));\n```\n\nThe `mapNode` method takes a function node and an array of inputs, calls the function node over each element in the input, and returns an array of results. The `node` parameter is a `NodeOrVoidNode` type, and the `inputs` parameter is an array of any type representing the inputs to the function node. The `stripTags` parameter is an optional boolean that determines whether to strip tags from the result. The method returns a promise that resolves to an array of any type. Here's an example of how to use the `mapNode` method:\n\n```javascript\nconst node = functionNode;\nconst inputs = [input1, input2, input3];\nconst engine = new EngineImpl(opStore);\nengine.mapNode(node, inputs, true)\n  .then(result => console.log(result))\n  .catch(error => console.error(error));\n```\n\nThe `Engine` interface is essential for managing the execution of nodes in the larger `weave-js` project. It provides a way to execute and map nodes in the computation pipeline, allowing developers to build complex data processing workflows using the `weave-js` library. The `executeNodes` and `mapNode` methods provide a flexible and powerful way to work with nodes in the computation pipeline, making it easier to build and maintain complex data processing applications.",
  "questions": ""
}