{
  "fileName": "nbformat.v4.schema.json",
  "filePath": "weave-js/src/common/types/libs/ipynb/schemas/nbformat.v4.schema.json",
  "url": "https://github.com/wandb/weave/weave-js/src/common/types/libs/ipynb/schemas/nbformat.v4.schema.json",
  "summary": "This code defines a JSON schema for Jupyter Notebook v4.5. The schema is used to validate the structure and data types of a Jupyter Notebook file. It ensures that the notebook file follows the correct format and contains the necessary properties.\n\nThe schema is organized into several sections:\n\n1. **Root-level properties**: These include `metadata`, `nbformat_minor`, `nbformat`, and `cells`. The `metadata` property contains notebook-level metadata, such as kernel information (`kernelspec`) and programming language information (`language_info`). The `cells` property is an array of cell objects, which can be of different types (code, markdown, or raw).\n\n2. **Cell definitions**: The schema defines various cell types, including `raw_cell`, `markdown_cell`, and `code_cell`. Each cell type has its own set of required properties, such as `id`, `cell_type`, `metadata`, and `source`. Code cells also have additional properties like `outputs` and `execution_count`.\n\n3. **Output definitions**: The schema defines different output types for code cells, including `execute_result`, `display_data`, `stream`, and `error`. Each output type has its own set of required properties, such as `output_type`, `data`, and `metadata`.\n\n4. **Miscellaneous definitions**: This section includes reusable definitions for various properties, such as `metadata_name`, `metadata_tags`, `attachments`, `source`, `execution_count`, `mimebundle`, `output_metadata`, and `multiline_string`.\n\nHere's an example of how this schema can be used to validate a Jupyter Notebook file:\n\n```json\n{\n  \"metadata\": {\n    \"kernelspec\": {\n      \"name\": \"python3\",\n      \"display_name\": \"Python 3\"\n    },\n    \"language_info\": {\n      \"name\": \"python\",\n      \"codemirror_mode\": \"python\",\n      \"file_extension\": \".py\",\n      \"mimetype\": \"text/x-python\",\n      \"pygments_lexer\": \"python\"\n    }\n  },\n  \"nbformat_minor\": 5,\n  \"nbformat\": 4,\n  \"cells\": [\n    {\n      \"id\": \"cell1\",\n      \"cell_type\": \"markdown\",\n      \"metadata\": {},\n      \"source\": \"This is a markdown cell.\"\n    },\n    {\n      \"id\": \"cell2\",\n      \"cell_type\": \"code\",\n      \"metadata\": {},\n      \"source\": \"print('Hello, world!')\",\n      \"outputs\": [],\n      \"execution_count\": 1\n    }\n  ]\n}\n```\n\nThis JSON object represents a Jupyter Notebook with two cells: a markdown cell and a code cell. The schema ensures that the notebook has the correct structure and properties, such as `metadata`, `nbformat_minor`, `nbformat`, and `cells`.",
  "questions": "1. **What is the purpose of this JSON schema?**\n\n   This JSON schema is designed to define the structure and validation rules for Jupyter Notebook v4.5 files. It specifies the required properties, types, and additional constraints for various components of a Jupyter Notebook, such as cells, metadata, and outputs.\n\n2. **How are different cell types (e.g., code, markdown, raw) represented in this schema?**\n\n   Different cell types are represented as separate definitions within the schema, such as `code_cell`, `markdown_cell`, and `raw_cell`. Each cell type has its own set of required properties and constraints, and the `cell` definition uses the `oneOf` keyword to specify that a cell must match one of these specific cell type definitions.\n\n3. **How are cell outputs handled in this schema?**\n\n   Cell outputs are represented by the `output` definition, which uses the `oneOf` keyword to specify that an output must match one of the defined output types: `execute_result`, `display_data`, `stream`, or `error`. Each output type has its own set of required properties and constraints, such as `output_type`, `data`, and `metadata`."
}