{
  "fileName": "mappers.py",
  "filePath": "weave/mappers.py",
  "url": "https://github.com/wandb/weave/weave/mappers.py",
  "summary": "The code defines a Mapper class and a make_mapper function. The Mapper class has an __init__ method that takes in four arguments: type_, mapper, artifact, and path. The type_ argument is the type of the object being mapped, mapper is a function that maps the object, artifact is the artifact being mapped, and path is the path to the artifact. The class has a result_type method that raises a NotImplementedError and an apply method that takes in an object and returns either a dictionary or any other type.\n\nThe make_mapper function takes in a map_fn argument, which is a function that maps an object. It returns a new function called mapper that takes in four arguments: type_, artifact, path, and mapper_options. The mapper function calls the map_fn function with the same arguments and returns the result.\n\nThis code is likely used in the larger project to map objects to a specific format or structure. The Mapper class can be subclassed to create custom mappers for different types of objects. The make_mapper function can be used to create a new mapper function that uses a specific map_fn function. For example, if we have a list of objects that we want to map to a dictionary format, we can create a new mapper function using make_mapper and pass in a map_fn function that maps each object to a dictionary. We can then use this new mapper function to map the list of objects to a list of dictionaries.\n\nExample usage:\n\n```\nclass MyMapper(Mapper):\n    def result_type(self):\n        return dict\n\n    def apply(self, obj):\n        return {'name': obj.name, 'age': obj.age}\n\nmy_mapper = MyMapper(str, lambda x: x, 'my_artifact', ['path', 'to', 'artifact'])\nresult = my_mapper.apply({'name': 'John', 'age': 30})\nprint(result)  # {'name': 'John', 'age': 30}\n\nnew_mapper = make_mapper(lambda x: {'name': x['name'], 'age': x['age']})\nresult = new_mapper(str, 'my_artifact', ['path', 'to', 'artifact'], mapper_options=None).apply({'name': 'John', 'age': 30})\nprint(result)  # {'name': 'John', 'age': 30}\n```",
  "questions": "1. What is the purpose of the `Mapper` class?\n   - The `Mapper` class is used to define a mapping function that can be applied to an object of a certain type.\n\n2. What is the purpose of the `make_mapper` function?\n   - The `make_mapper` function is used to create a new mapper function based on a given mapping function.\n\n3. What is the significance of the `typing.TYPE_CHECKING` check?\n   - The `typing.TYPE_CHECKING` check is used to import modules that are only needed for type checking, but not for runtime execution."
}