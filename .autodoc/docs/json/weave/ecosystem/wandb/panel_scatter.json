{
  "fileName": "panel_scatter.py",
  "filePath": "weave/ecosystem/wandb/panel_scatter.py",
  "url": "https://github.com/wandb/weave/weave/ecosystem/wandb/panel_scatter.py",
  "summary": "The `weave` module is being imported along with other modules. Two classes are defined in this file: `ScatterConfig` and `Scatter`. \n\n`ScatterConfig` is a dataclass that defines the configuration for a scatter plot. It has three fields: `x_fn`, `y_fn`, and `label_fn`. Each of these fields is a `weave.Node` object that represents a function that takes an input and returns an output. The default value for each field is a `weave.graph.VoidNode`, which is a node that does nothing. \n\n`Scatter` is a subclass of `weave.Panel` that represents a scatter plot panel. It has four fields: `id`, `input_node`, `config`, and `_renderAsPanel`. `id` is a string that identifies the panel. `input_node` is a `weave.Node` object that represents the input data for the scatter plot. `config` is an optional `ScatterConfig` object that represents the configuration for the scatter plot. `_renderAsPanel` is an optional `weave_plotly.PanelPlotly` object that represents the rendered scatter plot. \n\n`Scatter` has four methods: `initialize`, `render_config`, `render`, and `selected`. \n\n`initialize` is an operation that initializes the `ScatterConfig` object based on the input data. It first unnests the input data using the `weave.ops.unnest` operation. It then defines the `x_fn`, `y_fn`, and `label_fn` fields of the `ScatterConfig` object using `weave.define_fn`. Each of these functions simply returns the input item. The `ScatterConfig` object is returned. \n\n`render_config` is an operation that renders the configuration editor for the scatter plot. It first gets the `ScatterConfig` object from `self.config`. It then creates a `weave.panels.Group` object that contains three `weave.panels.LabeledItem` objects. Each `LabeledItem` object contains a `weave.panels.FunctionEditor` object that represents the function for the corresponding `ScatterConfig` field. The `Group` object is returned. \n\n`render` is an operation that renders the scatter plot. It first gets the input data, `ScatterConfig` object, and unnested input data from `self.input_node`, `self.config`, and `weave.ops.unnest(self.input_node)`, respectively. It then checks if the `x_fn`, `y_fn`, and `label_fn` fields of the `ScatterConfig` object have the correct types using `weave.types.optional` and `weave.types.Float()`, `weave.types.String()`, and `weave.types.Invalid()`, respectively. If any of the fields have the wrong type, a `weave.panels.PanelHtml` object that contains the message \"No data\" is returned. Otherwise, the input data is mapped to a list of dictionaries using `unnested.map` and a lambda function that returns a dictionary with keys \"x\", \"y\", and \"label\" (if `label_fn` is not invalid) and values that are the result of applying `x_fn`, `y_fn`, and `label_fn` to the input item. The resulting list of dictionaries is passed to `weave_plotly.plotly_scatter`, which returns a `plotly.graph_objs.Figure` object. The `Figure` object is then passed to `weave_plotly.PanelPlotly`, which returns a `weave_plotly.PanelPlotly` object that represents the rendered scatter plot. \n\n`selected` is an operation that filters the input data based on the selected region of the scatter plot. It first gets the unnested input data and `ScatterConfig` object from `weave.ops.unnest(self.input_node)` and `self.config`, respectively. It then filters the input data using `unnested.filter` and a lambda function that returns a boolean value based on whether the x and y values of the input item are within the selected region. The filtered data is returned using `weave_internal.use`. \n\nOverall, this code defines a `Scatter` class that represents a scatter plot panel. The `Scatter` class has operations that initialize the configuration, render the configuration editor and scatter plot, and filter the input data based on the selected region. This class can be used in a larger project that involves creating interactive data visualizations using `weave`. \n\nExample usage:\n\n```\nimport numpy as np\nimport weave\n\n# create input data\nx = np.random.rand(100)\ny = np.random.rand(100)\ndata = [{\"x\": x[i], \"y\": y[i]} for i in range(100)]\n\n# create scatter plot panel\nscatter = Scatter(input_node=weave.data(data))\n\n# render configuration editor\nconfig_panel = scatter.render_config()\n\n# render scatter plot\nscatter_panel = scatter.render()\n\n# filter input data based on selected region\nscatter.config = ScatterConfig(\n    x_fn=weave.define_fn({\"item\": dict}, lambda item: item[\"x\"]),\n    y_fn=weave.define_fn({\"item\": dict}, lambda item: item[\"y\"]),\n    label_fn=weave.graph.VoidNode()\n)\nscatter._renderAsPanel = scatter_panel\nselected_data = scatter.selected()\n```",
  "questions": "1. What is the purpose of the `Scatter` class and how is it used within the `weave` project?\n- The `Scatter` class is a subclass of `weave.Panel` and is used to render a scatter plot within the `weave` project. It takes an input node and a `ScatterConfig` object as parameters and has several ops for initializing, rendering, and selecting data for the plot.\n\n2. What is the purpose of the `ScatterConfig` class and how is it used within the `Scatter` class?\n- The `ScatterConfig` class is used to store configuration options for the scatter plot, such as the x and y functions and label function. It is used within the `Scatter` class to define the default configuration and to render the configuration editor.\n\n3. What is the purpose of the `selected` op within the `Scatter` class and what does it do?\n- The `selected` op within the `Scatter` class is used to filter the input data based on a selected range of x and y values. It takes the current configuration and the input data, filters the data based on the selected range, and returns the filtered data as a new input node."
}